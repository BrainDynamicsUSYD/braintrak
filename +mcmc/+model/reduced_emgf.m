classdef reduced_emgf < mcmc.model.reduced
	% This model tests fitting with the EMG frequency allowed to vary

	properties
	end


	methods
		function self = reduced_emgf() % Constructor
			self.name = 'model_reduced_emgf';
				self.n_params = 8;
				self.param_names = {'X','Y','Z','Alpha','Beta','t0','EMGa','EMGf'};
				self.param_symbols = {'X','Y','Z','\alpha','\beta','t_0','A_{EMG}','f_{EMG}'};
				self.param_units = {'','','','s^{-1}','s^{-1}','ms','','Hz'};

				self.n_fitted = 8;
				self.skip_fit = zeros(1,self.n_fitted);
				self.initial_step_size = [0.1 0.1 0.1 20  100  0.002  1 1]; % GOOD
			   	self.limits = [ eps  -1   eps       10      100    0.075   0   10 ;...
			      		        1     1     1      100      800    0.14    1  50];

			    self.kmax = 4; % Number of modes to simulate
				self.p = model.params;
				self.p.phin = 1e-5;
			% Limits based on stability_3d and for reduced model, classic tent
			% Somewhat tighter ranges
			% EMG ranges based on spectfit output generated by sacha, speciically spec10000113.fit
		end


		function p = p_from_params(self,fitted_params) % Map parameters to point
			p = p_from_params@mcmc.model.reduced(self,fitted_params);
			p.emg_f = fitted_params(8);
		end
		
		function params = params_from_p(self,p) % Map point to parameters
			params = [p.xyz p.alpha(1) p.beta(1)/p.alpha(1) p.t0 p.emg_a p.emg_f];
		end

		function [chisq,P] = objective(self,pars) % Calculate the objective
			chisq = NaN;
			P = [];


			% Splitting this function allows inheritance after checking limits
		    if self.compute_Mtot % If this flag has been set to false, then these fields are already present
		        % Should be fine to let that just throw an undefined variable error later if this isn't the case
		        self.stab_Mtot = exp(1i*self.stab_w*pars(6));
		        self.spec_Mtot = exp(1i*self.spec_w*pars(6));
		    end

		    stab_L = 1./((1-1i*self.stab_w/pars(4)).*(1-1i*self.stab_w/pars(5)));
		    spec_L = 1./((1-1i*self.spec_w/pars(4)).*(1-1i*self.spec_w/pars(5)));
		    zprime = (pars(4)+pars(5))^2/(pars(4)*pars(5))*pars(3); % Effectively Gsrs

		    % cf. James corticothalamic dynamics eq 9
		    d = ((self.stab_gamma_prefactor) - pars(1)).*(1+stab_L.*stab_L.*zprime) - pars(2).*(1+zprime).*self.stab_Mtot;
		    stab=d(1)>0 && ~any(real(d(2:end))<0 & imag(d(2:end)).*imag(d(1:end-1))<0);

		    if ~stab
		    	return
		    end

		    % And the spectrum. At k = 0
		    one_plus_zprime = (1+zprime.*spec_L.*spec_L);

		    P = zeros(size(self.spec_w));
		    q2re2 = (self.spec_gamma_prefactor - pars(1) -(pars(2)*(1+zprime))./one_plus_zprime.*self.spec_Mtot);
		    k2u = self.k2u;
		    k2_volconduct = self.k2_volconduct;
		    re2 = self.p.re.^2;

		    for j = 1:size(k2u,1)
		        P = P + k2u(j,2).*abs(1./(one_plus_zprime.*(k2u(j,1)*re2+q2re2))).^2 * k2_volconduct(j); % For use with the efficient way
		    end
		    emg = (self.spec_w/(2*pi*pars(8))).^2./(1+(self.spec_w/(2*pi*pars(8))).^2).^2;

		    P = P + pars(7)*emg; % Add the EMG component

		    P = P./utils.mex_trapz(self.target_f(self.weights>0),P(self.weights>0));
		    P = self.normalization_target*P;
		    sqdiff = (abs(P-self.target_P)./self.target_P).^2; % This is the squared fractional difference
		    
		    if stab
		    	chisq = sum(sqdiff(:).*self.weights(:));
		    end

		end
		
		function [initial_values,prior_pp] = initialize_fit(self,target_f,target_P) % Return the first posterior/prior and initial values
			[initial_values,~] = initialize_fit@mcmc.model.reduced(self,target_f,target_P);
			initial_values(8) = 40;
			prior_pp = self.uniform_priors();
		end
		
	end
end


